# 组件架构设计

## 1. 概述

### 1.1 设计目标

本文档详细说明青羽书城前端组件架构设计，包括组件分类、设计原则、通信机制和最佳实践。

### 1.2 架构原则

- **组件化**：将UI拆分为独立、可复用的组件
- **单一职责**：每个组件只负责一个明确的功能
- **高内聚低耦合**：组件内部紧密相关，组件间松散耦合
- **可复用性**：组件设计考虑复用场景
- **可维护性**：代码结构清晰，易于理解和修改

## 2. 组件分层架构

### 2.1 三层架构模型

```
┌─────────────────────────────────────┐
│         页面层 (Pages)              │
│       业务逻辑组合和页面布局          │
├─────────────────────────────────────┤
│        业务组件层 (Business)         │
│       包含特定业务逻辑的组件          │
├─────────────────────────────────────┤
│        基础组件层 (Common)           │
│       纯UI组件，无业务逻辑            │
└─────────────────────────────────────┘
```

### 2.2 组件分类

#### 基础组件 (Common Components)

**特征**：
- 纯UI组件，不包含业务逻辑
- 高度可复用
- 通过props接收数据，通过events传递事件
- 可独立使用和测试

**示例**：
```vue
<!-- Button.vue - 基础按钮组件 -->
<template>
  <button 
    :class="buttonClass"
    :disabled="disabled"
    @click="handleClick"
  >
    <slot />
  </button>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  type: {
    type: String,
    default: 'default',
    validator: (val) => ['default', 'primary', 'success'].includes(val)
  },
  disabled: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['click'])

const buttonClass = computed(() => {
  return `btn btn-${props.type}`
})

const handleClick = () => {
  if (!props.disabled) {
    emit('click')
  }
}
</script>
```

#### 业务组件 (Business Components)

**特征**：
- 包含特定业务逻辑
- 与业务数据和API交互
- 复用性相对较低
- 组合使用基础组件

**示例**：
```vue
<!-- BookCard.vue - 书籍卡片业务组件 -->
<template>
  <div class="book-card" @click="handleClick">
    <img :src="book.cover" :alt="book.title" loading="lazy" />
    <h3>{{ book.title }}</h3>
    <p class="author">{{ book.author }}</p>
    <div class="tags">
      <el-tag v-for="tag in book.tags" :key="tag">
        {{ tag }}
      </el-tag>
    </div>
  </div>
</template>

<script setup>
const props = defineProps({
  book: {
    type: Object,
    required: true
  }
})

const emit = defineEmits(['click', 'favorite'])

const handleClick = () => {
  emit('click', props.book)
}
</script>
```

#### 页面组件 (Page Components)

**特征**：
- 组合多个组件形成完整页面
- 处理页面级别的状态管理
- 与路由系统集成
- 包含页面布局逻辑

**示例**：
```vue
<!-- HomePage.vue - 首页组件 -->
<template>
  <div class="home-page">
    <BannerCarousel :banners="banners" />
    
    <section class="book-section">
      <h2>推荐书籍</h2>
      <BookGrid 
        :books="recommendBooks"
        :loading="loading"
        @book-click="handleBookClick"
      />
    </section>
    
    <section class="ranking-section">
      <h2>热门榜单</h2>
      <RankingList :rankings="rankings" />
    </section>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useBookstoreStore } from '@/stores/bookstore'
import { useRouter } from 'vue-router'

const bookstore = useBookstoreStore()
const router = useRouter()

const banners = ref([])
const recommendBooks = ref([])
const rankings = ref([])
const loading = ref(false)

onMounted(async () => {
  await bookstore.fetchHomepageData()
  banners.value = bookstore.getHomepageBanners
  recommendBooks.value = bookstore.getRecommendBooks
  rankings.value = bookstore.getRankings
})

const handleBookClick = (book) => {
  router.push(`/books/${book.id}`)
}
</script>
```

#### 布局组件 (Layout Components)

**特征**：
- 负责页面整体布局
- 提供页面框架结构
- 包含公共的头部、底部等
- 通过插槽接收页面内容

**示例**：
```vue
<!-- MainLayout.vue - 主布局组件 -->
<template>
  <div class="main-layout">
    <Header />
    
    <main class="main-content">
      <slot />
    </main>
    
    <Footer />
  </div>
</template>

<script setup>
import Header from './Header.vue'
import Footer from './Footer.vue'
</script>
```

## 3. 组件设计原则

### 3.1 Props设计原则

#### 原则1：明确的类型定义

```javascript
// ✅ 好的做法
props: {
  title: {
    type: String,
    required: true
  },
  count: {
    type: Number,
    default: 0,
    validator: (value) => value >= 0
  },
  items: {
    type: Array,
    default: () => []
  }
}

// ❌ 不好的做法
props: {
  title: String,  // 缺少required
  count: Number,  // 缺少默认值
  items: Array    // 对象/数组缺少工厂函数
}
```

#### 原则2：避免props修改

```javascript
// ✅ 好的做法
const props = defineProps({
  modelValue: String
})
const emit = defineEmits(['update:modelValue'])

const localValue = computed({
  get: () => props.modelValue,
  set: (val) => emit('update:modelValue', val)
})

// ❌ 不好的做法
const props = defineProps({
  value: String
})
// 直接修改props.value
```

### 3.2 Events设计原则

#### 原则1：使用kebab-case命名

```javascript
// ✅ 好的做法
emit('item-click', item)
emit('data-loaded')
emit('user-login')

// ❌ 不好的做法
emit('itemClick')
emit('dataLoaded')
```

#### 原则2：事件验证

```javascript
emits: {
  'item-click': (item) => {
    return item && item.id
  },
  'value-change': (value) => {
    return typeof value === 'string'
  }
}
```

### 3.3 Slots设计原则

#### 原则1：提供默认内容

```vue
<template>
  <div class="card">
    <div class="card-header">
      <slot name="header">
        <!-- 默认头部内容 -->
        <h3>默认标题</h3>
      </slot>
    </div>
    
    <div class="card-body">
      <slot>
        <!-- 默认主体内容 -->
        <p>暂无内容</p>
      </slot>
    </div>
  </div>
</template>
```

#### 原则2：作用域插槽传递数据

```vue
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      <slot name="item" :item="item" :index="index">
        <!-- 默认渲染 -->
        {{ item.name }}
      </slot>
    </li>
  </ul>
</template>
```

## 4. 组件通信机制

### 4.1 父子组件通信

```
父组件
  │
  ├─── Props ──→ 子组件
  │
  ←── Events ─── 子组件
```

**示例**：
```vue
<!-- 父组件 -->
<template>
  <ChildComponent 
    :data="parentData"
    @child-event="handleChildEvent"
  />
</template>

<!-- 子组件 -->
<script setup>
const props = defineProps({
  data: Object
})
const emit = defineEmits(['child-event'])

const handleAction = () => {
  emit('child-event', someData)
}
</script>
```

### 4.2 跨组件通信

#### 方式1：Provide/Inject

```vue
<!-- 祖先组件 -->
<script setup>
import { provide } from 'vue'

const theme = ref('light')
provide('theme', theme)
</script>

<!-- 后代组件 -->
<script setup>
import { inject } from 'vue'

const theme = inject('theme')
</script>
```

#### 方式2：Pinia Store

```javascript
// stores/app.js
export const useAppStore = defineStore('app', {
  state: () => ({
    theme: 'light'
  }),
  actions: {
    setTheme(theme) {
      this.theme = theme
    }
  }
})

// 在组件中使用
import { useAppStore } from '@/stores/app'

const app = useAppStore()
console.log(app.theme)
app.setTheme('dark')
```

### 4.3 兄弟组件通信

**推荐方式**：通过父组件中转或使用Store

```vue
<!-- 父组件中转 -->
<template>
  <ComponentA @data-change="handleDataChange" />
  <ComponentB :shared-data="sharedData" />
</template>

<script setup>
const sharedData = ref(null)

const handleDataChange = (data) => {
  sharedData.value = data
}
</script>
```

## 5. 组件复用策略

### 5.1 组合式函数 (Composables)

```javascript
// composables/useBookList.js
export function useBookList() {
  const books = ref([])
  const loading = ref(false)
  const error = ref(null)

  const fetchBooks = async (params) => {
    loading.value = true
    error.value = null
    
    try {
      const response = await bookAPI.getBooks(params)
      books.value = response.data
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }

  return {
    books,
    loading,
    error,
    fetchBooks
  }
}

// 在组件中使用
import { useBookList } from '@/composables/useBookList'

const { books, loading, fetchBooks } = useBookList()
```

### 5.2 渲染函数和JSX

```javascript
// 灵活的列表组件
import { h } from 'vue'

export default {
  props: {
    items: Array,
    renderItem: Function
  },
  setup(props) {
    return () => h(
      'ul',
      props.items.map(item => 
        h('li', { key: item.id }, props.renderItem(item))
      )
    )
  }
}
```

### 5.3 高阶组件模式

```javascript
// withLoading.js - 添加loading状态
export function withLoading(Component) {
  return {
    props: {
      ...Component.props,
      loading: Boolean
    },
    setup(props, { slots, attrs }) {
      return () => {
        if (props.loading) {
          return h('div', { class: 'loading' }, 'Loading...')
        }
        return h(Component, { ...props, ...attrs }, slots)
      }
    }
  }
}
```

## 6. 组件性能优化

### 6.1 组件懒加载

```javascript
// 路由懒加载
const routes = [
  {
    path: '/books',
    component: () => import('@/views/BooksView.vue')
  }
]

// 组件懒加载
const AsyncComponent = defineAsyncComponent(() =>
  import('@/components/HeavyComponent.vue')
)
```

### 6.2 使用v-memo优化

```vue
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.status]">
    <!-- 只在id或status变化时重新渲染 -->
    <BookCard :book="item" />
  </div>
</template>
```

### 6.3 使用shallowRef/shallowReactive

```javascript
// 对于大型不可变数据结构
const bigData = shallowRef({
  // 大量数据
})

// 只在需要时深度响应
watch(bigData, (newVal) => {
  // 处理变化
}, { deep: false })
```

## 7. 组件测试策略

### 7.1 单元测试

```javascript
// BookCard.test.js
import { mount } from '@vue/test-utils'
import BookCard from '@/components/BookCard.vue'

describe('BookCard', () => {
  const book = {
    id: '1',
    title: 'Test Book',
    author: 'Test Author',
    cover: '/cover.jpg'
  }

  it('renders book info correctly', () => {
    const wrapper = mount(BookCard, {
      props: { book }
    })
    
    expect(wrapper.text()).toContain('Test Book')
    expect(wrapper.text()).toContain('Test Author')
  })

  it('emits click event', async () => {
    const wrapper = mount(BookCard, {
      props: { book }
    })
    
    await wrapper.trigger('click')
    
    expect(wrapper.emitted('click')).toBeTruthy()
    expect(wrapper.emitted('click')[0][0]).toEqual(book)
  })
})
```

### 7.2 组件快照测试

```javascript
it('matches snapshot', () => {
  const wrapper = mount(BookCard, {
    props: { book }
  })
  
  expect(wrapper.html()).toMatchSnapshot()
})
```

## 8. 组件目录结构

### 8.1 推荐目录结构

```
src/components/
├── common/              # 基础组件
│   ├── Button/
│   │   ├── index.vue
│   │   ├── Button.test.js
│   │   └── README.md
│   ├── Input/
│   └── Dialog/
│
├── business/           # 业务组件
│   ├── BookCard/
│   │   ├── index.vue
│   │   ├── BookCard.test.js
│   │   └── types.js
│   ├── BookGrid/
│   └── RankingList/
│
└── layout/            # 布局组件
    ├── Header/
    ├── Footer/
    └── MainLayout/
```

### 8.2 组件命名规范

```javascript
// ✅ 好的命名
BookCard.vue        // 多词组件名
UserProfile.vue
BookList.vue

// ❌ 不好的命名
Card.vue           // 单词组件名
book.vue          // 小写
book-card.vue     // kebab-case（文件名用PascalCase）
```

## 9. 最佳实践总结

### 9.1 组件设计检查清单

- [ ] 组件职责单一明确
- [ ] Props类型定义完整
- [ ] Events命名规范
- [ ] 提供合理的默认值
- [ ] 包含必要的验证
- [ ] 考虑复用场景
- [ ] 编写单元测试
- [ ] 添加组件文档

### 9.2 性能优化检查清单

- [ ] 使用路由懒加载
- [ ] 大组件异步加载
- [ ] 合理使用v-memo
- [ ] 避免不必要的响应式
- [ ] 列表使用虚拟滚动
- [ ] 图片懒加载
- [ ] 防抖节流处理

### 9.3 可维护性检查清单

- [ ] 代码结构清晰
- [ ] 注释完整准确
- [ ] 遵循命名规范
- [ ] 避免magic number
- [ ] 提取公共逻辑
- [ ] 保持组件纯净

## 10. 参考资料

- [Vue 3 组件基础](https://vuejs.org/guide/essentials/component-basics.html)
- [Vue 3 组件通信](https://vuejs.org/guide/components/provide-inject.html)
- [组合式函数](https://vuejs.org/guide/reusability/composables.html)
- [组件测试](https://test-utils.vuejs.org/)

---

**文档版本**：v1.0.0  
**创建时间**：2025年10月13日  
**最后更新**：2025年10月13日  
**维护者**：前端架构师

