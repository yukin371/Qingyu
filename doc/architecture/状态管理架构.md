# 状态管理架构

## 1. 概述

### 1.1 状态管理目标

本文档详细说明青羽书城前端基于Pinia的状态管理架构设计，包括Store设计、数据流管理和最佳实践。

### 1.2 为什么需要状态管理

- **数据共享**：多个组件需要访问相同的数据
- **状态同步**：保持应用状态的一致性
- **可预测性**：统一的数据流向，易于追踪状态变化
- **可测试性**：独立的状态逻辑，便于测试
- **开发工具**：强大的Vue DevTools支持

## 2. Pinia架构设计

### 2.1 为什么选择Pinia

| 特性 | Pinia | Vuex 4 |
|------|-------|--------|
| API简洁度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| TypeScript支持 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| DevTools | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 包体积 | 1KB | 2KB |
| 模块化 | 原生支持 | 需要配置 |
| 学习曲线 | 平缓 | 陡峭 |

### 2.2 Store设计原则

#### 原则1：按功能模块划分Store

```javascript
stores/
├── app.js          # 应用全局状态
├── user.js         # 用户相关状态
├── bookstore.js    # 书城相关状态
├── reader.js       # 阅读器相关状态
└── cart.js         # 购物车相关状态
```

#### 原则2：保持Store简洁

```javascript
// ✅ 好的做法 - 单一职责
export const useUserStore = defineStore('user', {
  state: () => ({
    userInfo: null,
    token: null,
    isLoggedIn: false
  }),
  
  actions: {
    async login(credentials) {
      // 登录逻辑
    },
    
    logout() {
      // 登出逻辑
    }
  }
})

// ❌ 不好的做法 - 职责混乱
export const useAppStore = defineStore('app', {
  state: () => ({
    user: null,
    books: [],
    cart: [],
    theme: 'light',
    // ... 太多不相关的状态
  })
})
```

## 3. Store设计模式

### 3.1 基础Store结构

```javascript
// stores/bookstore.js
import { defineStore } from 'pinia'
import { bookstoreAPI } from '@/api/bookstore'

export const useBookstoreStore = defineStore('bookstore', {
  // 状态定义
  state: () => ({
    homepageData: null,
    books: [],
    rankings: [],
    loading: false,
    error: null
  }),

  // Getters - 计算属性
  getters: {
    // 获取首页Banner
    getHomepageBanners(state) {
      return state.homepageData?.banners || []
    },
    
    // 获取推荐书籍
    getRecommendBooks(state) {
      return state.homepageData?.recommendBooks || []
    },
    
    // 带参数的getter
    getBookById: (state) => (id) => {
      return state.books.find(book => book.id === id)
    }
  },

  // Actions - 异步操作和业务逻辑
  actions: {
    // 获取首页数据
    async fetchHomepageData() {
      this.loading = true
      this.error = null
      
      try {
        const response = await bookstoreAPI.getHomepage()
        this.homepageData = response.data
      } catch (error) {
        this.error = error.message
        throw error
      } finally {
        this.loading = false
      }
    },
    
    // 获取书籍列表
    async fetchBooks(params) {
      try {
        const response = await bookstoreAPI.getBooks(params)
        this.books = response.data
      } catch (error) {
        console.error('获取书籍失败:', error)
        throw error
      }
    },
    
    // 清除数据
    clearData() {
      this.homepageData = null
      this.books = []
      this.error = null
    }
  }
})
```

### 3.2 组合式Store（Composition API风格）

```javascript
// stores/user.js
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', () => {
  // State
  const userInfo = ref(null)
  const token = ref(localStorage.getItem('token'))
  
  // Getters
  const isLoggedIn = computed(() => !!token.value)
  const username = computed(() => userInfo.value?.username || '游客')
  
  // Actions
  async function login(credentials) {
    try {
      const response = await authAPI.login(credentials)
      token.value = response.data.token
      userInfo.value = response.data.user
      
      // 持久化token
      localStorage.setItem('token', token.value)
    } catch (error) {
      throw error
    }
  }
  
  function logout() {
    token.value = null
    userInfo.value = null
    localStorage.removeItem('token')
  }
  
  return {
    userInfo,
    token,
    isLoggedIn,
    username,
    login,
    logout
  }
})
```

### 3.3 Store间通信

```javascript
// stores/cart.js
import { defineStore } from 'pinia'
import { useUserStore } from './user'

export const useCartStore = defineStore('cart', {
  state: () => ({
    items: []
  }),
  
  actions: {
    async syncCart() {
      const userStore = useUserStore()
      
      // 只有登录用户才同步购物车
      if (userStore.isLoggedIn) {
        const response = await cartAPI.getCart()
        this.items = response.data
      }
    },
    
    addItem(book) {
      const userStore = useUserStore()
      
      if (!userStore.isLoggedIn) {
        // 提示登录
        return
      }
      
      // 添加到购物车
      this.items.push(book)
    }
  }
})
```

## 4. 数据流架构

### 4.1 单向数据流

```
┌─────────────────────────────────────┐
│         View (组件)                  │
│         用户交互                     │
└─────────────┬───────────────────────┘
              │ dispatch action
              ▼
┌─────────────────────────────────────┐
│         Actions                      │
│         异步操作/业务逻辑              │
└─────────────┬───────────────────────┘
              │ 更新state
              ▼
┌─────────────────────────────────────┐
│         State                        │
│         应用状态                      │
└─────────────┬───────────────────────┘
              │ 响应式更新
              ▼
┌─────────────────────────────────────┐
│         View (组件)                  │
│         视图更新                     │
└─────────────────────────────────────┘
```

### 4.2 数据流示例

```vue
<!-- BookListPage.vue -->
<template>
  <div class="book-list-page">
    <!-- 1. View层展示数据 -->
    <div v-if="bookstore.loading">加载中...</div>
    <div v-else>
      <BookCard 
        v-for="book in bookstore.books"
        :key="book.id"
        :book="book"
        @click="handleBookClick"
      />
    </div>
  </div>
</template>

<script setup>
import { onMounted } from 'vue'
import { useBookstoreStore } from '@/stores/bookstore'
import { useRouter } from 'vue-router'

const bookstore = useBookstoreStore()
const router = useRouter()

// 2. 组件挂载时dispatch action
onMounted(() => {
  bookstore.fetchBooks({ page: 1, size: 20 })
})

// 3. 用户交互触发action
const handleBookClick = (book) => {
  router.push(`/books/${book.id}`)
}
</script>
```

## 5. 状态持久化

### 5.1 本地存储策略

```javascript
// stores/user.js
export const useUserStore = defineStore('user', {
  state: () => ({
    token: localStorage.getItem('token'),
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    preferences: JSON.parse(localStorage.getItem('preferences') || '{}')
  }),
  
  actions: {
    login(credentials) {
      // 登录逻辑...
      
      // 持久化
      localStorage.setItem('token', this.token)
      localStorage.setItem('userInfo', JSON.stringify(this.userInfo))
    },
    
    logout() {
      this.token = null
      this.userInfo = null
      
      // 清除持久化数据
      localStorage.removeItem('token')
      localStorage.removeItem('userInfo')
    }
  }
})
```

### 5.2 使用Pinia插件持久化

```javascript
// plugins/pinia-persist.js
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

export default pinia
```

```javascript
// stores/user.js
export const useUserStore = defineStore('user', {
  state: () => ({
    token: null,
    userInfo: null
  }),
  
  // 配置持久化
  persist: {
    key: 'qingyu-user',
    storage: localStorage,
    paths: ['token', 'userInfo']  // 只持久化指定字段
  }
})
```

## 6. 异步操作处理

### 6.1 标准异步Action模式

```javascript
export const useBookstoreStore = defineStore('bookstore', {
  state: () => ({
    books: [],
    loading: false,
    error: null
  }),
  
  actions: {
    async fetchBooks(params) {
      // 1. 开始加载
      this.loading = true
      this.error = null
      
      try {
        // 2. API调用
        const response = await bookstoreAPI.getBooks(params)
        
        // 3. 更新状态
        this.books = response.data
        
        return response.data
      } catch (error) {
        // 4. 错误处理
        this.error = error.message
        console.error('获取书籍失败:', error)
        throw error
      } finally {
        // 5. 结束加载
        this.loading = false
      }
    }
  }
})
```

### 6.2 并发请求处理

```javascript
actions: {
  async fetchAllData() {
    this.loading = true
    
    try {
      // 并发请求
      const [banners, books, rankings] = await Promise.all([
        bookstoreAPI.getBanners(),
        bookstoreAPI.getBooks(),
        bookstoreAPI.getRankings()
      ])
      
      this.banners = banners.data
      this.books = books.data
      this.rankings = rankings.data
    } catch (error) {
      this.error = error.message
      throw error
    } finally {
      this.loading = false
    }
  }
}
```

### 6.3 请求去重

```javascript
export const useBookstoreStore = defineStore('bookstore', {
  state: () => ({
    books: [],
    loading: false,
    _fetchBooksPromise: null  // 存储请求Promise
  }),
  
  actions: {
    async fetchBooks(params) {
      // 如果正在请求，返回现有Promise
      if (this._fetchBooksPromise) {
        return this._fetchBooksPromise
      }
      
      this.loading = true
      
      // 创建新Promise
      this._fetchBooksPromise = bookstoreAPI.getBooks(params)
        .then(response => {
          this.books = response.data
          return response.data
        })
        .finally(() => {
          this.loading = false
          this._fetchBooksPromise = null
        })
      
      return this._fetchBooksPromise
    }
  }
})
```

## 7. 最佳实践

### 7.1 命名规范

```javascript
// ✅ 好的命名
const useUserStore = defineStore('user', {
  state: () => ({
    userInfo: null,     // 使用camelCase
    isLoggedIn: false,  // boolean使用is前缀
    hasPermission: false
  }),
  
  getters: {
    getUserName() {},   // getter使用get前缀
    isAdmin() {}        // boolean getter使用is前缀
  },
  
  actions: {
    fetchUserInfo() {}, // 获取数据使用fetch前缀
    updateProfile() {}, // 更新使用update前缀
    deleteAccount() {}  // 删除使用delete前缀
  }
})
```

### 7.2 错误处理

```javascript
actions: {
  async fetchData() {
    try {
      const response = await api.getData()
      this.data = response.data
    } catch (error) {
      // 区分错误类型
      if (error.response) {
        // 服务器返回错误
        this.error = error.response.data.message
      } else if (error.request) {
        // 请求发出但无响应
        this.error = '网络错误，请检查网络连接'
      } else {
        // 其他错误
        this.error = error.message
      }
      
      // 上报错误日志
      console.error('Store Error:', error)
      
      // 抛出错误供组件处理
      throw error
    }
  }
}
```

### 7.3 状态重置

```javascript
export const useBookstoreStore = defineStore('bookstore', {
  state: () => ({
    books: [],
    filter: {
      category: '',
      keyword: ''
    },
    pagination: {
      page: 1,
      size: 20,
      total: 0
    }
  }),
  
  actions: {
    // 重置为初始状态
    $reset() {
      this.books = []
      this.filter = {
        category: '',
        keyword: ''
      }
      this.pagination = {
        page: 1,
        size: 20,
        total: 0
      }
    }
  }
})
```

## 8. 在组件中使用Store

### 8.1 Options API风格

```vue
<script>
import { mapState, mapActions } from 'pinia'
import { useBookstoreStore } from '@/stores/bookstore'

export default {
  computed: {
    ...mapState(useBookstoreStore, ['books', 'loading'])
  },
  
  methods: {
    ...mapActions(useBookstoreStore, ['fetchBooks'])
  },
  
  mounted() {
    this.fetchBooks()
  }
}
</script>
```

### 8.2 Composition API风格（推荐）

```vue
<script setup>
import { onMounted } from 'vue'
import { useBookstoreStore } from '@/stores/bookstore'
import { storeToRefs } from 'pinia'

const bookstore = useBookstoreStore()

// 使用storeToRefs保持响应性
const { books, loading } = storeToRefs(bookstore)

// 直接解构actions
const { fetchBooks } = bookstore

onMounted(() => {
  fetchBooks()
})
</script>
```

## 9. Store测试

### 9.1 测试Store

```javascript
// stores/__tests__/bookstore.test.js
import { setActivePinia, createPinia } from 'pinia'
import { useBookstoreStore } from '../bookstore'
import { vi } from 'vitest'

describe('Bookstore Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('fetches books successfully', async () => {
    const store = useBookstoreStore()
    const mockBooks = [{ id: '1', title: 'Test Book' }]
    
    // Mock API
    vi.spyOn(bookstoreAPI, 'getBooks').mockResolvedValue({
      data: mockBooks
    })
    
    await store.fetchBooks()
    
    expect(store.books).toEqual(mockBooks)
    expect(store.loading).toBe(false)
  })
  
  it('handles fetch error', async () => {
    const store = useBookstoreStore()
    
    vi.spyOn(bookstoreAPI, 'getBooks').mockRejectedValue(
      new Error('API Error')
    )
    
    await expect(store.fetchBooks()).rejects.toThrow('API Error')
    expect(store.error).toBe('API Error')
  })
})
```

## 10. 参考资料

- [Pinia官方文档](https://pinia.vuejs.org/)
- [Vue 3状态管理](https://vuejs.org/guide/scaling-up/state-management.html)
- [Pinia vs Vuex](https://pinia.vuejs.org/introduction.html#comparison-with-vuex)

---

**文档版本**：v1.0.0  
**创建时间**：2025年10月13日  
**最后更新**：2025年10月13日  
**维护者**：前端架构师

