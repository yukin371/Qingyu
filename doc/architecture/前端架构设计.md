# 青羽书城前端架构设计

## 1. 架构概述

### 1.1 设计目标

青羽书城前端架构旨在构建一个现代化、可扩展、高性能的书城展示系统，主要目标包括：

- **用户体验优先**：提供流畅、响应式的用户界面
- **组件化设计**：构建可复用、可维护的组件体系
- **性能优化**：实现快速加载和流畅交互
- **可扩展性**：支持功能模块的灵活扩展
- **开发效率**：提供良好的开发体验和工具链

### 1.2 技术选型

| 技术栈 | 选择 | 版本 | 选型理由 |
|--------|------|------|----------|
| 前端框架 | Vue 3 | ^3.4.0 | 组合式API、更好的TypeScript支持、性能优化 |
| UI组件库 | Element Plus | ^2.4.0 | 丰富的组件、Vue 3原生支持、企业级UI |
| 状态管理 | Pinia | ^2.1.0 | Vue官方推荐、类型安全、开发工具支持 |
| 路由管理 | Vue Router | ^4.2.0 | Vue官方路由、支持动态路由和守卫 |
| HTTP客户端 | Axios | ^1.6.0 | Promise支持、拦截器、请求/响应处理 |
| 构建工具 | Vite | ^5.0.0 | 快速热更新、优化的生产构建、ES模块支持 |
| 开发语言 | JavaScript | ES2022 | 现代语法特性、良好的生态支持 |

### 1.3 架构原则

- **单一职责原则**：每个组件和模块只负责一个明确的功能
- **开闭原则**：对扩展开放，对修改封闭
- **依赖倒置原则**：依赖抽象而不是具体实现
- **组合优于继承**：通过组合实现功能复用
- **约定优于配置**：遵循统一的开发约定

## 2. 整体架构

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                        表现层 (Presentation Layer)            │
├─────────────────────────────────────────────────────────────┤
│  Pages (页面)     │  Components (组件)  │  Layouts (布局)    │
├─────────────────────────────────────────────────────────────┤
│                        业务逻辑层 (Business Layer)            │
├─────────────────────────────────────────────────────────────┤
│  Stores (状态管理) │  Composables (组合函数) │ Services (服务) │
├─────────────────────────────────────────────────────────────┤
│                        数据访问层 (Data Access Layer)         │
├─────────────────────────────────────────────────────────────┤
│  API (接口)       │  Utils (工具)       │  Constants (常量)  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

#### 2.2.1 核心模块 (Core Modules)
- **App Shell**：应用外壳，包含导航、布局等
- **Router**：路由管理和导航控制
- **Store**：全局状态管理
- **API Client**：HTTP请求和响应处理

#### 2.2.2 业务模块 (Business Modules)
- **书城首页 (Homepage)**：Banner轮播、榜单展示、推荐内容
- **榜单系统 (Rankings)**：实时榜、周榜、月榜、新人榜
- **书籍展示 (Books)**：书籍列表、详情、搜索
- **用户系统 (User)**：登录、注册、个人中心

#### 2.2.3 共享模块 (Shared Modules)
- **UI Components**：可复用的UI组件
- **Utils**：工具函数和辅助方法
- **Constants**：常量定义
- **Types**：类型定义（如使用TypeScript）

## 3. 组件架构

### 3.1 组件分类

#### 3.1.1 基础组件 (Base Components)
通用的、无业务逻辑的UI组件：
```
components/base/
├── BaseButton.vue          # 基础按钮
├── BaseInput.vue           # 基础输入框
├── BaseModal.vue           # 基础弹窗
├── BaseLoading.vue         # 加载组件
└── BaseEmpty.vue           # 空状态组件
```

#### 3.1.2 业务组件 (Business Components)
包含特定业务逻辑的组件：
```
components/business/
├── BannerCarousel.vue      # Banner轮播
├── RankingList.vue         # 榜单列表
├── BookGrid.vue            # 书籍网格
├── BookCard.vue            # 书籍卡片
└── SearchBox.vue           # 搜索框
```

#### 3.1.3 布局组件 (Layout Components)
页面布局相关组件：
```
components/layout/
├── AppHeader.vue           # 页面头部
├── AppFooter.vue           # 页面底部
├── AppSidebar.vue          # 侧边栏
└── AppContainer.vue        # 容器组件
```

### 3.2 组件通信模式

#### 3.2.1 父子组件通信
```vue
<!-- 父组件 -->
<template>
  <BookGrid 
    :books="books"
    :loading="loading"
    @book-click="handleBookClick"
  />
</template>

<!-- 子组件 -->
<script>
export default {
  props: ['books', 'loading'],
  emits: ['book-click'],
  setup(props, { emit }) {
    const handleClick = (book) => {
      emit('book-click', book)
    }
    return { handleClick }
  }
}
</script>
```

#### 3.2.2 跨组件通信
使用 Pinia 进行状态管理：
```javascript
// stores/bookstore.js
export const useBookstoreStore = defineStore('bookstore', {
  state: () => ({
    selectedBook: null,
    favorites: []
  }),
  
  actions: {
    selectBook(book) {
      this.selectedBook = book
    }
  }
})
```

### 3.3 组件设计模式

#### 3.3.1 容器组件模式 (Container Pattern)
```vue
<!-- BookListContainer.vue -->
<template>
  <BookList 
    :books="books"
    :loading="loading"
    @load-more="loadMore"
  />
</template>

<script>
export default {
  setup() {
    const store = useBookstoreStore()
    const { books, loading } = storeToRefs(store)
    
    const loadMore = () => {
      store.fetchMoreBooks()
    }
    
    return { books, loading, loadMore }
  }
}
</script>
```

#### 3.3.2 组合式函数模式 (Composables Pattern)
```javascript
// composables/useBookList.js
export function useBookList() {
  const books = ref([])
  const loading = ref(false)
  
  const fetchBooks = async () => {
    loading.value = true
    try {
      const response = await bookstoreAPI.getBooks()
      books.value = response.data
    } finally {
      loading.value = false
    }
  }
  
  return {
    books: readonly(books),
    loading: readonly(loading),
    fetchBooks
  }
}
```

## 4. 状态管理架构

### 4.1 Pinia Store 设计

#### 4.1.1 Store 结构
```javascript
// stores/bookstore.js
export const useBookstoreStore = defineStore('bookstore', {
  // 状态定义
  state: () => ({
    // 首页数据
    homepageData: null,
    
    // 榜单数据
    rankings: {
      realtime: [],
      weekly: [],
      monthly: [],
      newbie: []
    },
    
    // 加载状态
    loading: {
      homepage: false,
      rankings: false
    },
    
    // 错误状态
    errors: {}
  }),

  // 计算属性
  getters: {
    getHomepageBanners: (state) => {
      return state.homepageData?.banners || []
    },
    
    getRankingByType: (state) => {
      return (type) => state.rankings[type] || []
    }
  },

  // 异步操作
  actions: {
    async fetchHomepageData() {
      this.loading.homepage = true
      try {
        const response = await bookstoreAPI.getHomepage()
        this.homepageData = response.data
      } catch (error) {
        this.errors.homepage = error.message
      } finally {
        this.loading.homepage = false
      }
    }
  }
})
```

#### 4.1.2 Store 模块化
```
stores/
├── index.js                # Store 入口
├── modules/
│   ├── bookstore.js        # 书城相关状态
│   ├── user.js             # 用户相关状态
│   ├── ui.js               # UI状态管理
│   └── cache.js            # 缓存管理
└── plugins/
    ├── persistence.js      # 持久化插件
    └── logger.js           # 日志插件
```

### 4.2 状态管理最佳实践

#### 4.2.1 状态规范化
```javascript
// 规范化的状态结构
state: () => ({
  // 实体数据
  entities: {
    books: {},
    authors: {},
    categories: {}
  },
  
  // 列表数据
  lists: {
    homepage: [],
    rankings: {
      realtime: [],
      weekly: []
    }
  },
  
  // UI状态
  ui: {
    loading: {},
    errors: {},
    pagination: {}
  }
})
```

#### 4.2.2 异步操作模式
```javascript
actions: {
  async fetchData(params) {
    const loadingKey = `fetch_${params.type}`
    
    this.setLoading(loadingKey, true)
    this.clearError(loadingKey)
    
    try {
      const response = await api.fetchData(params)
      this.setData(params.type, response.data)
      return response.data
    } catch (error) {
      this.setError(loadingKey, error.message)
      throw error
    } finally {
      this.setLoading(loadingKey, false)
    }
  }
}
```

## 5. 路由架构

### 5.1 路由结构设计

```javascript
// router/index.js
const routes = [
  {
    path: '/',
    name: 'Layout',
    component: () => import('@/layouts/DefaultLayout.vue'),
    children: [
      {
        path: '',
        name: 'Home',
        component: () => import('@/views/HomeView.vue'),
        meta: { title: '首页' }
      },
      {
        path: '/rankings',
        name: 'Rankings',
        component: () => import('@/views/RankingsView.vue'),
        meta: { title: '榜单' }
      },
      {
        path: '/books',
        name: 'Books',
        component: () => import('@/views/BooksView.vue'),
        children: [
          {
            path: ':id',
            name: 'BookDetail',
            component: () => import('@/views/BookDetailView.vue'),
            props: true
          }
        ]
      }
    ]
  }
]
```

### 5.2 路由守卫

```javascript
// router/guards.js
export function setupRouterGuards(router) {
  // 全局前置守卫
  router.beforeEach(async (to, from, next) => {
    // 设置页面标题
    document.title = to.meta.title || '青羽书城'
    
    // 权限检查
    if (to.meta.requiresAuth && !isAuthenticated()) {
      next('/login')
      return
    }
    
    next()
  })
  
  // 全局后置守卫
  router.afterEach((to, from) => {
    // 页面访问统计
    analytics.track('page_view', {
      path: to.path,
      name: to.name
    })
  })
}
```

## 6. API 架构

### 6.1 HTTP 客户端设计

```javascript
// api/client.js
import axios from 'axios'

// 创建 axios 实例
const client = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
client.interceptors.request.use(
  (config) => {
    // 添加认证token
    const token = getAuthToken()
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    // 添加请求ID用于追踪
    config.headers['X-Request-ID'] = generateRequestId()
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
client.interceptors.response.use(
  (response) => {
    return response.data
  },
  (error) => {
    // 统一错误处理
    handleApiError(error)
    return Promise.reject(error)
  }
)
```

### 6.2 API 模块化

```javascript
// api/modules/bookstore.js
export const bookstoreAPI = {
  // 首页数据
  getHomepage() {
    return client.get('/bookstore/homepage')
  },
  
  // 榜单数据
  getRanking(type, params = {}) {
    return client.get(`/bookstore/rankings/${type}`, { params })
  },
  
  // 书籍数据
  getBooks(params = {}) {
    return client.get('/bookstore/books', { params })
  },
  
  getBookById(id) {
    return client.get(`/bookstore/books/${id}`)
  },
  
  // 搜索
  searchBooks(keyword, filters = {}) {
    return client.get('/bookstore/books/search', {
      params: { keyword, ...filters }
    })
  }
}
```

### 6.3 缓存策略

```javascript
// api/cache.js
class APICache {
  constructor() {
    this.cache = new Map()
    this.ttl = new Map()
  }
  
  set(key, data, ttl = 5 * 60 * 1000) {
    this.cache.set(key, data)
    this.ttl.set(key, Date.now() + ttl)
  }
  
  get(key) {
    if (this.isExpired(key)) {
      this.delete(key)
      return null
    }
    return this.cache.get(key)
  }
  
  isExpired(key) {
    const expireTime = this.ttl.get(key)
    return expireTime && Date.now() > expireTime
  }
}

// 使用缓存装饰器
export function withCache(ttl = 5 * 60 * 1000) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value
    
    descriptor.value = async function(...args) {
      const cacheKey = `${propertyKey}_${JSON.stringify(args)}`
      
      // 尝试从缓存获取
      const cached = cache.get(cacheKey)
      if (cached) {
        return cached
      }
      
      // 执行原方法
      const result = await originalMethod.apply(this, args)
      
      // 缓存结果
      cache.set(cacheKey, result, ttl)
      
      return result
    }
  }
}
```

## 7. 性能优化架构

### 7.1 代码分割策略

```javascript
// 路由级别的代码分割
const routes = [
  {
    path: '/books',
    component: () => import(
      /* webpackChunkName: "books" */ 
      '@/views/BooksView.vue'
    )
  }
]

// 组件级别的代码分割
export default {
  components: {
    HeavyComponent: () => import('./HeavyComponent.vue')
  }
}
```

### 7.2 资源优化

```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // 第三方库分离
          vendor: ['vue', 'vue-router', 'pinia'],
          elementPlus: ['element-plus'],
          
          // 业务模块分离
          bookstore: [
            './src/views/HomeView.vue',
            './src/views/BooksView.vue'
          ]
        }
      }
    }
  },
  
  // 图片优化
  assetsInclude: ['**/*.svg'],
  
  // 预加载优化
  optimizeDeps: {
    include: ['element-plus/es']
  }
}
```

### 7.3 渲染优化

```vue
<!-- 使用 v-memo 优化列表渲染 -->
<template>
  <div 
    v-for="book in books" 
    :key="book.id"
    v-memo="[book.id, book.title, book.updateTime]"
  >
    <BookCard :book="book" />
  </div>
</template>

<!-- 使用 Suspense 处理异步组件 -->
<template>
  <Suspense>
    <template #default>
      <AsyncBookList />
    </template>
    <template #fallback>
      <BookListSkeleton />
    </template>
  </Suspense>
</template>
```

## 8. 错误处理架构

### 8.1 全局错误处理

```javascript
// main.js
app.config.errorHandler = (error, instance, info) => {
  console.error('全局错误:', error)
  console.error('错误信息:', info)
  
  // 发送错误报告
  errorReporter.report(error, {
    component: instance?.$options.name,
    info
  })
}

// 未捕获的Promise错误
window.addEventListener('unhandledrejection', (event) => {
  console.error('未处理的Promise错误:', event.reason)
  errorReporter.report(event.reason)
})
```

### 8.2 组件错误边界

```vue
<!-- ErrorBoundary.vue -->
<template>
  <div v-if="hasError" class="error-boundary">
    <h3>出现了一些问题</h3>
    <p>{{ errorMessage }}</p>
    <el-button @click="retry">重试</el-button>
  </div>
  <slot v-else />
</template>

<script>
export default {
  data() {
    return {
      hasError: false,
      errorMessage: ''
    }
  },
  
  errorCaptured(error, instance, info) {
    this.hasError = true
    this.errorMessage = error.message
    
    // 阻止错误继续传播
    return false
  },
  
  methods: {
    retry() {
      this.hasError = false
      this.errorMessage = ''
      this.$forceUpdate()
    }
  }
}
</script>
```

## 9. 测试架构

### 9.1 测试策略

```
测试金字塔
    ┌─────────────┐
    │   E2E Tests │  <- 少量，关键用户流程
    ├─────────────┤
    │ Integration │  <- 中等数量，组件集成
    │    Tests    │
    ├─────────────┤
    │ Unit Tests  │  <- 大量，工具函数和组件
    └─────────────┘
```

### 9.2 测试工具配置

```javascript
// vitest.config.js
export default {
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/setup.js'],
    coverage: {
      reporter: ['text', 'html'],
      threshold: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  }
}
```

## 10. 部署架构

### 10.1 构建流程

```yaml
# .github/workflows/deploy.yml
name: Deploy Frontend

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm run test
      
      - name: Build
        run: npm run build
        env:
          VITE_API_BASE_URL: ${{ secrets.API_BASE_URL }}
      
      - name: Deploy
        run: npm run deploy
```

### 10.2 环境配置

```javascript
// 环境变量配置
const config = {
  development: {
    API_BASE_URL: 'http://localhost:8080/api/v1',
    DEBUG: true
  },
  
  staging: {
    API_BASE_URL: 'https://staging-api.qingyu.com/api/v1',
    DEBUG: false
  },
  
  production: {
    API_BASE_URL: 'https://api.qingyu.com/api/v1',
    DEBUG: false
  }
}
```

## 11. 监控和分析

### 11.1 性能监控

```javascript
// utils/performance.js
export class PerformanceMonitor {
  static measurePageLoad() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0]
      
      const metrics = {
        dns: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcp: navigation.connectEnd - navigation.connectStart,
        request: navigation.responseStart - navigation.requestStart,
        response: navigation.responseEnd - navigation.responseStart,
        dom: navigation.domContentLoadedEventEnd - navigation.responseEnd,
        load: navigation.loadEventEnd - navigation.loadEventStart
      }
      
      // 发送性能数据
      analytics.track('page_performance', metrics)
    })
  }
  
  static measureComponentRender(componentName) {
    const start = performance.now()
    
    return () => {
      const end = performance.now()
      const duration = end - start
      
      analytics.track('component_render', {
        component: componentName,
        duration
      })
    }
  }
}
```

### 11.2 用户行为分析

```javascript
// composables/useAnalytics.js
export function useAnalytics() {
  const trackEvent = (event, properties = {}) => {
    analytics.track(event, {
      ...properties,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    })
  }
  
  const trackPageView = (pageName) => {
    trackEvent('page_view', { page: pageName })
  }
  
  const trackClick = (element, context = {}) => {
    trackEvent('click', {
      element,
      ...context
    })
  }
  
  return {
    trackEvent,
    trackPageView,
    trackClick
  }
}
```

## 12. 安全架构

### 12.1 XSS 防护

```javascript
// utils/security.js
export function sanitizeHTML(html) {
  const div = document.createElement('div')
  div.textContent = html
  return div.innerHTML
}

// 在组件中使用
export default {
  computed: {
    safeContent() {
      return sanitizeHTML(this.userContent)
    }
  }
}
```

### 12.2 CSRF 防护

```javascript
// api/client.js
client.interceptors.request.use((config) => {
  // 添加 CSRF token
  const csrfToken = getCsrfToken()
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken
  }
  
  return config
})
```

## 13. 总结

青羽书城前端架构采用现代化的技术栈和设计模式，通过分层架构、组件化设计、状态管理等方式，构建了一个可扩展、高性能、易维护的前端系统。

### 13.1 架构优势

- **技术先进**：采用 Vue 3 + Vite 等现代技术栈
- **结构清晰**：分层架构和模块化设计
- **性能优化**：代码分割、缓存策略、渲染优化
- **开发效率**：完善的工具链和开发规范
- **质量保证**：全面的测试策略和错误处理

### 13.2 持续改进

- 定期技术栈升级和性能优化
- 根据业务需求扩展功能模块
- 完善监控和分析体系
- 优化用户体验和开发体验

---

**文档版本**：v1.0.0  
**最后更新**：2024年1月  
**维护者**：前端架构团队