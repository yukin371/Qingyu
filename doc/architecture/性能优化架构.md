# 性能优化架构

## 1. 概述

### 1.1 性能优化目标

本文档详细说明青羽书城前端的性能优化架构设计，涵盖加载性能、运行时性能、网络优化等多个方面。

### 1.2 性能指标

#### Core Web Vitals（核心Web指标）

| 指标 | 含义 | 目标值 | 说明 |
|------|------|--------|------|
| **LCP** | Largest Contentful Paint | < 2.5s | 最大内容绘制时间 |
| **FID** | First Input Delay | < 100ms | 首次输入延迟 |
| **CLS** | Cumulative Layout Shift | < 0.1 | 累积布局偏移 |

#### 其他关键指标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **FCP** | < 1.5s | 首次内容绘制 |
| **TTI** | < 3.5s | 可交互时间 |
| **TBT** | < 200ms | 总阻塞时间 |
| **Speed Index** | < 3s | 速度指数 |

## 2. 加载性能优化

### 2.1 代码分割策略

#### 路由级别分割

```javascript
// ✅ 推荐：按路由分割
const router = createRouter({
  routes: [
    {
      path: '/books',
      component: () => import('@/views/books/BookListView.vue')
    },
    {
      path: '/user',
      component: () => import('@/views/user/UserCenterView.vue')
    }
  ]
})
```

#### 组件级别分割

```javascript
// 异步组件
import { defineAsyncComponent } from 'vue'

export default {
  components: {
    // 大型组件异步加载
    HeavyChart: defineAsyncComponent(() =>
      import('@/components/HeavyChart.vue')
    ),
    
    // 带加载状态的异步组件
    AsyncComponent: defineAsyncComponent({
      loader: () => import('@/components/AsyncComponent.vue'),
      loadingComponent: LoadingSpinner,
      errorComponent: ErrorComponent,
      delay: 200,
      timeout: 3000
    })
  }
}
```

#### 第三方库分割

```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // 框架核心
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          
          // UI框架
          'element-plus': ['element-plus'],
          
          // 工具库
          'utils': ['axios', 'dayjs'],
          
          // 图表库（如果使用）
          'charts': ['echarts']
        }
      }
    }
  }
}
```

### 2.2 资源优化

#### 图片优化

```vue
<template>
  <div class="book-cover">
    <!-- 1. 懒加载 -->
    <img 
      :src="book.cover" 
      :alt="book.title"
      loading="lazy"
    />
    
    <!-- 2. 响应式图片 -->
    <img 
      :srcset="`
        ${book.cover}?w=300 300w,
        ${book.cover}?w=600 600w,
        ${book.cover}?w=900 900w
      `"
      sizes="(max-width: 600px) 300px, (max-width: 900px) 600px, 900px"
      :src="book.cover"
      alt="book cover"
    />
    
    <!-- 3. 现代格式 -->
    <picture>
      <source type="image/webp" :srcset="book.coverWebp" />
      <source type="image/jpeg" :srcset="book.cover" />
      <img :src="book.cover" alt="book cover" />
    </picture>
  </div>
</template>
```

#### 图片压缩配置

```javascript
// vite.config.js
import viteImagemin from 'vite-plugin-imagemin'

export default {
  plugins: [
    viteImagemin({
      gifsicle: {
        optimizationLevel: 7,
        interlaced: false
      },
      optipng: {
        optimizationLevel: 7
      },
      mozjpeg: {
        quality: 80
      },
      pngquant: {
        quality: [0.8, 0.9],
        speed: 4
      },
      svgo: {
        plugins: [
          { name: 'removeViewBox' },
          { name: 'removeEmptyAttrs', active: false }
        ]
      }
    })
  ]
}
```

#### 字体优化

```css
/* 字体预加载 */
@font-face {
  font-family: 'CustomFont';
  src: url('/fonts/custom.woff2') format('woff2');
  font-display: swap; /* 防止字体阻塞渲染 */
  unicode-range: U+4E00-9FA5; /* 仅加载中文字符 */
}
```

```html
<!-- index.html -->
<link rel="preload" href="/fonts/custom.woff2" as="font" type="font/woff2" crossorigin>
```

### 2.3 预加载策略

#### 资源预加载

```html
<!-- index.html -->
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="https://api.qingyu.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://cdn.qingyu.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="/js/app.js" as="script">
<link rel="preload" href="/css/main.css" as="style">

<!-- 预获取下一页资源 -->
<link rel="prefetch" href="/js/next-page.js">
```

#### 路由预加载

```javascript
// router/index.js
router.beforeEach((to, from, next) => {
  // 预加载相关页面
  if (to.name === 'BookList') {
    import('@/views/books/BookDetailView.vue')
  }
  
  if (to.name === 'BookDetail') {
    import('@/views/reader/ReaderView.vue')
  }
  
  next()
})
```

## 3. 运行时性能优化

### 3.1 虚拟列表

```vue
<!-- 使用虚拟滚动处理大量数据 -->
<template>
  <RecycleScroller
    :items="books"
    :item-size="200"
    key-field="id"
    v-slot="{ item }"
  >
    <BookCard :book="item" />
  </RecycleScroller>
</template>

<script setup>
import { RecycleScroller } from 'vue-virtual-scroller'
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css'

const books = ref(/* 大量数据 */)
</script>
```

### 3.2 组件缓存优化

```vue
<template>
  <router-view v-slot="{ Component }">
    <!-- 缓存特定组件 -->
    <keep-alive :include="['BookList', 'UserCenter']" :max="10">
      <component :is="Component" />
    </keep-alive>
  </router-view>
</template>
```

```vue
<!-- 使用v-memo优化列表渲染 -->
<template>
  <div 
    v-for="book in books" 
    :key="book.id"
    v-memo="[book.id, book.title, book.updateTime]"
  >
    <BookCard :book="book" />
  </div>
</template>
```

### 3.3 计算属性优化

```javascript
// ✅ 好的做法 - 使用computed缓存
const expensiveComputed = computed(() => {
  return books.value.filter(book => book.rating > 4.5)
    .sort((a, b) => b.rating - a.rating)
})

// ❌ 不好的做法 - 每次都重新计算
const expensiveMethod = () => {
  return books.value.filter(book => book.rating > 4.5)
    .sort((a, b) => b.rating - a.rating)
}
```

### 3.4 防抖和节流

```javascript
// composables/useDebounce.js
import { ref } from 'vue'

export function useDebounce(fn, delay = 300) {
  let timeout
  
  return function(...args) {
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

export function useThrottle(fn, delay = 300) {
  let lastCall = 0
  
  return function(...args) {
    const now = Date.now()
    
    if (now - lastCall >= delay) {
      lastCall = now
      fn.apply(this, args)
    }
  }
}
```

```vue
<script setup>
import { useDebounce, useThrottle } from '@/composables/useDebounce'

// 搜索输入防抖
const debouncedSearch = useDebounce((keyword) => {
  search(keyword)
}, 500)

// 滚动事件节流
const throttledScroll = useThrottle(() => {
  handleScroll()
}, 200)
</script>
```

### 3.5 Web Worker

```javascript
// workers/dataProcessor.worker.js
self.addEventListener('message', (e) => {
  const { data, action } = e.data
  
  switch (action) {
    case 'process':
      const processed = processData(data)
      self.postMessage({ result: processed })
      break
  }
})

function processData(data) {
  // 复杂的数据处理
  return data.map(item => ({
    ...item,
    processed: true
  }))
}
```

```javascript
// 在组件中使用Worker
import DataWorker from '@/workers/dataProcessor.worker?worker'

const worker = new DataWorker()

worker.postMessage({
  action: 'process',
  data: largeDataSet
})

worker.addEventListener('message', (e) => {
  console.log('处理完成:', e.data.result)
})
```

## 4. 网络性能优化

### 4.1 HTTP缓存策略

```javascript
// utils/request.js
import axios from 'axios'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000
})

// 请求缓存
const cache = new Map()

api.interceptors.request.use(config => {
  // GET请求启用缓存
  if (config.method === 'get' && config.cache) {
    const cacheKey = `${config.url}?${JSON.stringify(config.params)}`
    
    if (cache.has(cacheKey)) {
      const { data, timestamp } = cache.get(cacheKey)
      const now = Date.now()
      
      // 缓存有效期5分钟
      if (now - timestamp < 5 * 60 * 1000) {
        config.adapter = () => Promise.resolve({
          data,
          status: 200,
          statusText: 'OK (cached)',
          headers: {},
          config
        })
      }
    }
  }
  
  return config
})

api.interceptors.response.use(response => {
  // 缓存GET请求响应
  if (response.config.method === 'get' && response.config.cache) {
    const cacheKey = `${response.config.url}?${JSON.stringify(response.config.params)}`
    cache.set(cacheKey, {
      data: response.data,
      timestamp: Date.now()
    })
  }
  
  return response
})
```

### 4.2 请求优化

```javascript
// 请求合并
import { debounce } from 'lodash-es'

class RequestBatcher {
  constructor() {
    this.queue = []
    this.flush = debounce(this._flush.bind(this), 50)
  }
  
  add(id) {
    this.queue.push(id)
    this.flush()
  }
  
  async _flush() {
    const ids = [...this.queue]
    this.queue = []
    
    // 批量请求
    const response = await api.post('/books/batch', { ids })
    return response.data
  }
}

const batcher = new RequestBatcher()
```

```javascript
// 请求取消
import axios from 'axios'

const pendingRequests = new Map()

export function cancelPendingRequests() {
  pendingRequests.forEach(cancel => cancel())
  pendingRequests.clear()
}

api.interceptors.request.use(config => {
  const key = `${config.method}:${config.url}`
  
  // 取消之前的相同请求
  if (pendingRequests.has(key)) {
    pendingRequests.get(key)()
  }
  
  config.cancelToken = new axios.CancelToken(cancel => {
    pendingRequests.set(key, cancel)
  })
  
  return config
})
```

### 4.3 资源压缩

```javascript
// vite.config.js
import viteCompression from 'vite-plugin-compression'

export default {
  plugins: [
    viteCompression({
      algorithm: 'gzip',
      ext: '.gz',
      threshold: 10240,  // 10KB以上才压缩
      deleteOriginFile: false
    }),
    viteCompression({
      algorithm: 'brotliCompress',
      ext: '.br',
      threshold: 10240
    })
  ]
}
```

## 5. 渲染性能优化

### 5.1 CSS优化

```css
/* 使用transform替代position */
/* ❌ 不好 */
.element {
  position: absolute;
  left: 100px;
}

/* ✅ 好 */
.element {
  transform: translateX(100px);
  will-change: transform;
}

/* 避免昂贵的CSS属性 */
.avoid {
  box-shadow: 0 0 10px rgba(0,0,0,0.5); /* 昂贵 */
  filter: blur(5px); /* 昂贵 */
}

/* 使用contain优化 */
.card {
  contain: layout style paint;
}
```

### 5.2 减少重排重绘

```javascript
// ❌ 不好 - 多次触发重排
element.style.width = '100px'
element.style.height = '100px'
element.style.margin = '10px'

// ✅ 好 - 批量修改
element.classList.add('optimized-class')

// 或使用cssText
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;'
```

### 5.3 优化动画

```css
/* 使用CSS动画替代JS动画 */
.fade-in {
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

/* 使用transform和opacity（GPU加速） */
.animated {
  transform: translateZ(0); /* 开启GPU加速 */
  will-change: transform, opacity;
}
```

## 6. 构建优化

### 6.1 生产构建配置

```javascript
// vite.config.js
export default {
  build: {
    // 压缩选项
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,  // 移除console
        drop_debugger: true  // 移除debugger
      }
    },
    
    // 分块策略
    chunkSizeWarningLimit: 1000,
    rollupOptions: {
      output: {
        // 静态资源分类
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: '[ext]/[name]-[hash].[ext]'
      }
    },
    
    // CSS代码分割
    cssCodeSplit: true,
    
    // sourcemap（生产环境关闭）
    sourcemap: false
  }
}
```

### 6.2 Tree Shaking

```javascript
// ✅ 使用ES模块导入
import { debounce } from 'lodash-es'

// ❌ 避免整体导入
import _ from 'lodash'

// ✅ Element Plus按需导入
import { ElButton, ElMessage } from 'element-plus'
```

### 6.3 代码压缩

```javascript
// vite.config.js
import { visualizer } from 'rollup-plugin-visualizer'

export default {
  plugins: [
    // 分析打包体积
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true
    })
  ]
}
```

## 7. 监控和分析

### 7.1 性能监控

```javascript
// utils/performance.js
export class PerformanceMonitor {
  static measure(name, startMark, endMark) {
    try {
      performance.measure(name, startMark, endMark)
      const measure = performance.getEntriesByName(name)[0]
      console.log(`${name}: ${measure.duration}ms`)
      return measure.duration
    } catch (error) {
      console.error('Performance measurement failed:', error)
    }
  }
  
  static markStart(name) {
    performance.mark(`${name}-start`)
  }
  
  static markEnd(name) {
    performance.mark(`${name}-end`)
    return this.measure(name, `${name}-start`, `${name}-end`)
  }
}

// 使用示例
PerformanceMonitor.markStart('fetchBooks')
await fetchBooks()
PerformanceMonitor.markEnd('fetchBooks')
```

### 7.2 Core Web Vitals监控

```javascript
// utils/webVitals.js
import { onCLS, onFID, onLCP } from 'web-vitals'

export function initWebVitals() {
  onCLS(console.log)
  onFID(console.log)
  onLCP(console.log)
}

// main.js
import { initWebVitals } from '@/utils/webVitals'

if (import.meta.env.PROD) {
  initWebVitals()
}
```

### 7.3 错误监控

```javascript
// utils/errorMonitor.js
export function setupErrorMonitor() {
  // 捕获Vue错误
  app.config.errorHandler = (err, instance, info) => {
    console.error('Vue Error:', err, info)
    // 上报错误
    reportError(err, { component: instance?.$options.name, info })
  }
  
  // 捕获全局错误
  window.addEventListener('error', (event) => {
    console.error('Global Error:', event.error)
    reportError(event.error)
  })
  
  // 捕获Promise错误
  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled Promise:', event.reason)
    reportError(event.reason)
  })
}
```

## 8. 性能优化清单

### 8.1 加载性能

- [ ] 实现代码分割和懒加载
- [ ] 优化图片（压缩、WebP、懒加载）
- [ ] 配置资源预加载和预获取
- [ ] 启用HTTP/2和压缩
- [ ] 优化字体加载
- [ ] 减小第三方库体积

### 8.2 运行时性能

- [ ] 使用虚拟列表处理大数据
- [ ] 合理使用keep-alive和v-memo
- [ ] 优化计算属性和侦听器
- [ ] 实现防抖和节流
- [ ] 避免不必要的响应式数据

### 8.3 渲染性能

- [ ] 优化CSS（减少重排重绘）
- [ ] 使用CSS动画替代JS
- [ ] 启用GPU加速
- [ ] 减少DOM操作
- [ ] 优化长列表渲染

### 8.4 网络性能

- [ ] 实现请求缓存
- [ ] 合并和批量请求
- [ ] 取消重复请求
- [ ] 启用CDN加速
- [ ] 优化API响应体积

## 9. 参考资料

- [Web性能优化](https://web.dev/performance/)
- [Core Web Vitals](https://web.dev/vitals/)
- [Vue性能优化](https://vuejs.org/guide/best-practices/performance.html)
- [Vite性能优化](https://vitejs.dev/guide/performance.html)

---

**文档版本**：v1.0.0  
**创建时间**：2025年10月13日  
**最后更新**：2025年10月13日  
**维护者**：前端架构师

